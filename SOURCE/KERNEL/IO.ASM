;=======================================================================
;
;IO.DISPLAY - VIDEO AND DISPLAY ROUTINES, ANYTHING GRAPHICAL
;
;=======================================================================

;IN = SI: STRING
;OUT = N/A
DISPLAY_PRINT_TEXT:
	PUSH AX
	PUSH SI
	MOV AH, 0EH
.LOOP:
	LODSB
	CMP AL, 0
	JE .END
	INT 10H
	JMP .LOOP
.END:
	POP SI
	POP AX
	RET
	
;IN = AL: CHARACTER
;OUT = N/A
DISPLAY_PRINT_CHAR:
	CMP AL, 0
	JE NEAR .END
	PUSH AX
	MOV AH, 0EH
	INT 10H
.END:
	POP AX
	RET
	
;=======================================================================
;
;IO.KEYBOARD - INPUT/USER INPUT STUFF
;
;=======================================================================
	
;IN = N/A
;OUT = AL: CHARACTER PRESSED
KEYBOARD_KEYPRESS:
	XOR AX, AX
	INT 16H
	RET
	
;IN = CH: NUMBER OF CHARS TO READ, DI: BUFFER
;OUT = DI: STRING
KEYBOARD_INPUT:
	PUSH AX
	PUSH CX
	PUSH DI
	XOR CL, CL
.LOOP:
	MOV AH, 0
	INT 16H
	
	CMP AL, 10 ;NEWLINE (ENTER)
	JE .END
	CMP AL, 13
	JE .END
	CMP AL, 8 ;BACKSPACE
	JE .BACK
	CMP CL, CH ;DID WE INPUTED MORE CHARS THAN THE ONES WE SHOULD?
	JGE .END
	CMP AL, 'a' ;ALL UPPERCASE, NO LOWERCASE!
	JGE .IS_LOWERCASE
.PRINT_PART:
	CALL DISPLAY_PRINT_CHAR
	INC CL
	STOSB
	JMP .LOOP
.IS_LOWERCASE:
	CMP AL, 'z'
	JLE .OK_LOWERCASE
	JMP .PRINT_PART
.OK_LOWERCASE:
	SUB AL, 27+5 ;LOWERCASE-(27+5) = UPPERCASE
	JMP .PRINT_PART
.BACK:
	CMP CL, 0 ;REMOVE CHARACTER FROM STRING
	JE .LOOP
	DEC DI
	MOV BYTE [DI], 0
	DEC CL
	MOV AL, 8
	CALL DISPLAY_PRINT_CHAR
	MOV AL, ' '
	CALL DISPLAY_PRINT_CHAR
	MOV AL, 8
	CALL DISPLAY_PRINT_CHAR
	JMP .LOOP
.END:
	XOR AL, AL
	STOSB
	POP DI
	POP CX
	POP AX
	RET
	
;=======================================================================
;
;IO.STORAGE - FILESYSTEMS, CLOSE/OPEN/READ/WRITE FILES ON AFPFS SYSTEM
;
;=======================================================================

;IN = SI: FILENAME, AX: SEGMENT TO LOAD FILE TO
;OUT = CF: CLEAR IF SUCESS
DISK_LOAD_FILE:
	MOV WORD [.FILENAME], SI
	MOV WORD [.SEGMENT], AX
	MOV AX, 1
	CALL LOGICAL_TO_HTS
	MOV SI, BUFFER
	MOV BX, DS
	MOV ES, BX
	MOV BX, SI
	MOV AH, 2
	MOV AL, 24 ;READ ALL SECTORS
	PUSH_ALL
.READ_DISK:
	POP_ALL
	PUSH_ALL
	STC
	INT 13H
	JNC .PREPARE_BUFFER
	CALL RESET_DISK ;ERROR ON DISK?
	JNC .READ_DISK
	;ERROR
	STC
	RET
.PREPARE_BUFFER:
	POP_ALL
	PUSH_ALL
	MOV AX, DS ;NOW IT POINTS TO OUR BUFFER
	MOV ES, AX
	MOV DI, BUFFER
	XOR AX, AX
	MOV WORD [.SECT], AX ;SECTOR IS ZERO, FOR NOW
.FIND_FILENAME:
	ADD WORD [.SECT], 1 ;ADD ONE SECTOR PER LOOP
	MOV CX, 512 ;READ SECTOR PER SECTOR
.LOOP:
	XCHG CX, DX
	MOV SI, PROGRAM_TO_LOAD
	MOV CX, 9
	REP CMPSB
	JE SHORT .FOUND_FILE
	ADD AX, 1
	MOV DI, BUFFER
	ADD DI, AX
	XCHG DX, CX
	LOOP .LOOP
	CMP WORD [.SECT], 16 ;MORE THAN TOTAL SECTORS!
	JGE .NOT_FOUND
	JMP .FIND_FILENAME ;ANOTHER SECTOR...
.FOUND_FILE:
	MOV AX, WORD [.SEGMENT] ;MAKE ES:BX TO POINT TO OUR LOAD PLACE
	MOV ES, AX
	MOV BX, 0

	MOV AX, WORD [.SECT] ;SECTOR WHERE FILE IS
	CALL LOGICAL_TO_HTS
	
	MOV AH, 2 ;READ FROM THE CLUSTER WE FOUND THE FILENAME
	MOV AL, 18
	
	STC
	INT 13H
	JNC .END
	CALL RESET_DISK ;IF THERE IS ERROR, RESET FLOPPY
	JMP .FOUND_FILE
.END:
	POP_ALL
	CLC
	RET
	
.NOT_FOUND:
	POP_ALL
	STC
	RET
	
	.PTR						DW 0
	.SECT						DW 0
	.FILENAME					DW 0
	.SEGMENT					DW 0

;IN = JMP TO SPECIFIC ERROR
;OUT = CORRESPONDING STRING DISPLAYED
DISK_ERROR:
	;LETS SEE WICH ERROR WE HAVE...
	CMP AX, 01H
	JE .INVALID_COMMAND
	CMP AX, 02H
	JE .ADDRESS_MARK_NOT_FOUND
	CMP AX, 03H
	JE .WRITE_PROTECTED
	CMP AX, 04H
	JE .SECTOR_NOT_FOUND
	CMP AX, 05H
	JE .RESET_FAILED
	CMP AX, 06H
	JE .FLOPPY_DISK_REMOVED
	CMP AX, 07H
	JE .BAD_PARAMETER_TABLE
	CMP AX, 08H
	JE .DMA_OVERRUN
	CMP AX, 09H
	JE .DMA_CROSSED_64K
	CMP AX, 0AH
	JE .BAD_SECTOR_FLAG
	CMP AX, 0BH
	JE .BAD_TRACK_FLAG
	CMP AX, 0CH
	JE .MEDIA_TYPE_NOT_FOUND
	CMP AX, 0DH
	JE .INVALID_NUMBER_OF_SECTORS
	CMP AX, 0EH
	JE .CONTROL_DATA_ADDRESS_MARK
	CMP AX, 0FH
	JE .DMA_ARBITRATION_LEVEL_OUT_OF_RANGE
	CMP AX, 10H
	JE .UNCORRECTABLE_CRC_ECC_DATA_ERROR
	CMP AX, 11H
	JE .ECC_CORRECTED_DATA_ERROR
	CMP AX, 20H
	JE .CONTROLLER_FAILED
	CMP AX, 40H
	JE .SEEK_FAILED
	CMP AX, 80H
	JE .DISK_TIME_OUT
	CMP AX, 0AAH
	JE .DRIVE_NOT_READY
	CMP AX, 0BBH
	JE .UNDEFINED_ERROR
	CMP AX, 0CCH
	JE .WRITE_FAULT
	CMP AX, 0E0H
	JE .STATUS_REGISTER_ERROR
	CMP AX, 0FFH
	JE .SENSE_OPERATION_FAILED
	JMP .UNKNOWN ;NOT ANY OF THE ABOVE? WOW, I CANT BELIEVE THAT
	.INVALID_COMMAND:
		MOV SI, DISK_ERROR_STRING.INVALID_COMMAND
		JMP .PRINT
	.ADDRESS_MARK_NOT_FOUND:
		MOV SI, DISK_ERROR_STRING.ADDRESS_MARK_NOT_FOUND
		JMP .PRINT
	.WRITE_PROTECTED:
		MOV SI, DISK_ERROR_STRING.WRITE_PROTECTED
		JMP .PRINT
	.SECTOR_NOT_FOUND:
		MOV SI, DISK_ERROR_STRING.SECTOR_NOT_FOUND
		JMP .PRINT
	.RESET_FAILED:
		MOV SI, DISK_ERROR_STRING.RESET_FAILED
		JMP .PRINT
	.FLOPPY_DISK_REMOVED:
		MOV SI, DISK_ERROR_STRING.FLOPPY_DISK_REMOVED
		JMP .PRINT
	.BAD_PARAMETER_TABLE:
		MOV SI, DISK_ERROR_STRING.BAD_PARAMETER_TABLE
		JMP .PRINT
	.DMA_OVERRUN:
		MOV SI, DISK_ERROR_STRING.DMA_OVERRUN
		JMP .PRINT
	.DMA_CROSSED_64K:
		MOV SI, DISK_ERROR_STRING.DMA_CROSSED_64K
		JMP .PRINT
	.BAD_SECTOR_FLAG:
		MOV SI, DISK_ERROR_STRING.BAD_SECTOR_FLAG
		JMP .PRINT
	.BAD_TRACK_FLAG:
		MOV SI, DISK_ERROR_STRING.BAD_TRACK_FLAG
		JMP .PRINT
	.MEDIA_TYPE_NOT_FOUND:
		MOV SI, DISK_ERROR_STRING.MEDIA_TYPE_NOT_FOUND
		JMP .PRINT
	.INVALID_NUMBER_OF_SECTORS:
		MOV SI, DISK_ERROR_STRING.INVALID_NUMBER_OF_SECTORS
		JMP .PRINT
	.CONTROL_DATA_ADDRESS_MARK:
		MOV SI, DISK_ERROR_STRING.CONTROL_DATA_ADDRESS_MARK
		JMP .PRINT
	.DMA_ARBITRATION_LEVEL_OUT_OF_RANGE:
		MOV SI, DISK_ERROR_STRING.DMA_ARBITRATION_LEVEL_OUT_OF_RANGE
		JMP .PRINT
	.UNCORRECTABLE_CRC_ECC_DATA_ERROR:
		MOV SI, DISK_ERROR_STRING.UNCORRECTABLE_CRC_ECC_DATA_ERROR
		JMP .PRINT
	.ECC_CORRECTED_DATA_ERROR:
		MOV SI, DISK_ERROR_STRING.ECC_CORRECTED_DATA_ERROR
		JMP .PRINT
	.CONTROLLER_FAILED:
		MOV SI, DISK_ERROR_STRING.CONTROLLER_FAILED
		JMP .PRINT
	.SEEK_FAILED:
		MOV SI, DISK_ERROR_STRING.SEEK_FAILED
		JMP .PRINT
	.DISK_TIME_OUT:
		MOV SI, DISK_ERROR_STRING.DISK_TIME_OUT
		JMP .PRINT
	.DRIVE_NOT_READY:
		MOV SI, DISK_ERROR_STRING.DRIVE_NOT_READY
		JMP .PRINT
	.UNDEFINED_ERROR:
		MOV SI, DISK_ERROR_STRING.UNDEFINED_ERROR
		JMP .PRINT
	.WRITE_FAULT:
		MOV SI, DISK_ERROR_STRING.WRITE_FAULT
		JMP .PRINT
	.STATUS_REGISTER_ERROR:
		MOV SI, DISK_ERROR_STRING.STATUS_REGISTER_ERROR
		JMP .PRINT
	.SENSE_OPERATION_FAILED:
		MOV SI, DISK_ERROR_STRING.SENSE_OPERATION_FAILED
		JMP .PRINT
	.UNKNOWN:
		MOV SI, DISK_ERROR_STRING.UNKNOWN
	.PRINT:
		CALL DISPLAY_PRINT_TEXT
		STC
		RET ;RETURN BACK, AND ACTUALLY SHOULD END THE MAIN CALLER SINCE
			;THIS FUNCTION IS SUPPOSED TO BE JUMPED ON, NOT CALLED ON

;IN = N/A
;OUT = CARRY FLAG, CLEAR IF FAILURE
RESET_DISK:
	PUSH AX
	PUSH DX
	XOR AX, AX
	MOV DL, BYTE [DISK_INFO.DRIVE_NUMBER]
	STC ;SET CARRY FLAG
	INT 13H
	POP DX
	POP AX
	RET
	
;=======================================================================
;
;IO.CONVERSION - CONVERT X TO Y, AND VICEVERSA (IF POSSIBLE)
;
;=======================================================================

;IN = AX: LOGICAL SECTOR
;OUT = REGS FOR INT 13
LOGICAL_TO_HTS:
	PUSH BX
	PUSH AX
	MOV BX, AX ;SAVE LOGICAL SECTOR
	XOR DX, DX
	DIV WORD [DISK_INFO.SECTORS_PER_TRACK]
	ADD DL, 01H ;SECTORS STARTS AT 1
	MOV CL, DL ;CL IS FOR SECTORS
	MOV AX, BX
	XOR DX, DX ;CALCULATE HEAD
	DIV WORD [DISK_INFO.SECTORS_PER_TRACK]
	XOR DX, DX
	DIV WORD [DISK_INFO.SIDES]
	MOV DH, DL ;HEADS/SIDE
	MOV CH, AL ;TRACK
	POP AX ;RESTORE AX AND BX
	POP BX
	MOV DL, BYTE [DISK_INFO.DRIVE_NUMBER] ;SAVE DEVICE NUMBER
	RET

;IN = SI: KEYBOARD BUFFER (EXPRG.COM), DI: PLACE TO PUT AFPFS FILENAME
;OUT = DI: AFPFS READABLE FILENAME (EXPRG  COM)
AFPFS_FILENAME:
	PUSHA
	XOR CX, CX ;CX = 0
.LOOP:
	LODSB
	CMP AL, 0 ;NULL TERMINATOR
	JE .END
	CMP AL, '.' ;DOT
	JE .SPACE_LOOP
	CMP CX, 10 ;MORE THAN 11 CHARS
	JGE .END
	INC CX
	STOSB ;ELSE PUT THE CHAR
	JMP .LOOP
.SPACE_LOOP: ;PUT SPACES, UNTIL WE FIT 8.
	CMP CX, 6
	JE .LOOP
	MOV AL, ' '
	STOSB
	INC CX
	CMP CX, 8
	JL .SPACE_LOOP
	JMP .LOOP
.END:
	MOV AL, 0
	STOSB
	POPA
	RET
	
;=======================================================================
;
;IO.SYSTEM - SYSTEM RELATED STUFF, NOT OS, BUT RATHER ESSENTIAL ROUTINES
;
;=======================================================================

;IN = N/A
;OUT = N/A
SYSTEM_REBOOT:
	XOR AX, AX
	INT 19H
	HLT
	
;=======================================================================
;
;IO.SERIAL - IN-BUILT SERIAL DRIVER ROUTINES
;
;=======================================================================
	
;IN = DX: PORT NUMBER (NOT ADDRESS)
;OUT = N/A
SERIAL_ENABLE:
	PUSH AX
	MOV AH, 0
	MOV AL, 11100011B ;9600 BAUD RATE, NO PARITY
	INT 14H
	POP AX
	RET

;IN = N/A
;OUT = AL: NUMBER OF SERIAL PORTS
SERIAL_PORTS_CHECK:
	PUSH ES
	PUSH SI
	PUSH AX
	
	MOV AX, 0040H
	MOV ES, AX
	MOV BX, 0
	
	MOV AX, WORD [ES:BX] ;GET FIRST SERIAL PORT
	CMP AX, 0
	JE .NO_FIRST_SERIAL_PORT ;NOPE
	;WE HAVE SERIAL PORTS!
.YES_FIRST_SERIAL_PORT:
	MOV BX, 2
	
	MOV AX, WORD [ES:BX] ;GET SECOND SERIAL PORT
	CMP AX, 0
	JE .NO_SECOND_SERIAL_PORT ;NO
.YES_SECOND_SERIAL_PORT:
	MOV BX, 4
	
	MOV AX, WORD [ES:BX] ;GET THIRD SERIAL PORT
	CMP AX, 0
	JE .NO_THIRD_SERIAL_PORT ;OK, NO 3RD PORT
.YES_THIRD_SERIAL_PORT:
	MOV BX, 6
	
	MOV AX, WORD [ES:BX] ;GET FOURTH SERIAL PORT
	CMP AX, 0
	JE .NO_THIRD_SERIAL_PORT ;OH, ALMOST ALL PORTS
	
	MOV BYTE [.PORTS], 4 ;ALL PORTS!
.END:
	MOV AX, _KERNEL_ ;RESTORE SEGMENTS
	MOV ES, AX
	POP AX
	POP SI
	POP ES
	RET
	
.NO_FIRST_SERIAL_PORT:
	MOV BYTE [.PORTS], 0 ;ZERO PORTS, IF THERE IS NO REGISTRY HERE
	JMP .END
.NO_SECOND_SERIAL_PORT:
	MOV BYTE [.PORTS], 1 ;ONLY ONE PORT
	JMP .END
.NO_THIRD_SERIAL_PORT:
	MOV BYTE [.PORTS], 2 ;ONLY TWO PORTS
	JMP .END
.NO_FOURTH_SERIAL_PORT:
	MOV BYTE [.PORTS], 3 ;ONLY THREE PORTS
	JMP .END
	
	.PORTS	DB 0

;IN = DX: PORT ADDRESS, AL: BYTE TO SEND
;OUT = N/A
SERIAL_SEND_BYTE:
	PUSH AX
	PUSH DX
	OUT DX, AL
	POP DX
	POP AX
	RET
	
;IN = DX: PORT ADDRESS, SI: MEMORY LOCATION, CX: HOW MANY
;OUT = N/A
SERIAL_SEND_BYTES:
	PUSH CX
	PUSH DX
	PUSH AX
	PUSH SI
.LOOP:
	CMP CX, 0 ;IF COUNTER IS ZERO, END
	JE .END
	
	MOV AL, BYTE [SI]
	OUT DX, AL ;SEND BYTE TO PORT DX
	
	INC SI ;NEXT BYTE...
	DEC CX
	JMP .LOOP
.END:
	POP SI
	POP AX
	POP DX
	POP CX
	RET
	
;IN = DX: PORT ADDRESS
;OUT = AL: BYTE
SERIAL_GET_BYTE:
	PUSH DX
	IN AL, DX ;PUT STUFF GOT FROM DX TO AL
	POP DX
	RET
	
;=======================================================================
;
;IO.MEMORY - MEMORY ALLOCATION AND MANAGEMENT ROUTINES
;
;=======================================================================

;IN = SI: SOURCE, DI: DESTINATION, CX: BYTES TO COPY
;OUT = N/A
MEMORY_COPY:
	PUSHA
.LOOP:
	CMP CX, 0 ;DID WE ENDED YET?
	JE .END
	MOV AL, BYTE [SI]
	MOV BYTE [DI], AL
	
	INC DI
	INC SI
	
	DEC CX
	JMP .LOOP
.END:
	POPA
	RET

;IN = AL: BYTE TO COPY, DI: DESTINATION, CX: TIMES TO COPY CHAR
;OUT = N/A
MEMORY_COPY_BYTE:
	PUSHA
.LOOP:
	CMP CX, 0 ;IF WE ENDED, END
	JE .END
	MOV BYTE [DI], AL ;COPY AL TO DI
	ADD DI, 1
	SUB CX, 1
	JMP .LOOP
.END:
	POPA
	RET
	
;IN = N/A
;OUT = NOTHING TOO IMPORTANT/CRITICAL ;)
MEMORY_DESTROY_TABLE:
	;I FEEL LIKE I WANT TO DESTROY MY MEMORY TABLE
	;IM MAD, I WANT TO XOR IT COMPLELTELY
	;AND NO ONE IS GONNA STOP ME
	; - SUPERLEAF1995
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH ES
	MOV AX, _MEMORY_TABLE_
	MOV ES, AX
	XOR BX, BX
.DESTROY_ENTRY_NUMBER:
	;XOR SOMETHING, (USELESS SINCE 0.1.5)
	MOV WORD [ES:BX], 0
.ERASE_ENTRIES:
	;NOW LETS DELETE ALL ENTRIES (USELESS SINCE 0.1.5)
	MOV WORD [ES:BX], 0
	ADD BX, 1
	CMP BX, 0FFFAH
	JGE .END
	JMP .ERASE_ENTRIES
.END:
	POP ES ;DONE >:)
	POP CX
	POP BX
	POP AX
	RET
	
;IN = CX: SEGMENT, AL: FLAG
;OUT = ENTRY IN MEMORY TABLE
MEMORY_MANAGE:
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH ES
	
	CMP CX, 2FFFH ;NO SEGMENTS BELOW PROGRAM MEMORY (3000H)
	JLE .ERROR
	JMP .ERROR ;IF NOT A VALID FLAG, BAIL OUT
.CONT:
	MOV BYTE [.FLAG], BYTE AL
	
	MOV WORD [.TABLE_SEG], CX

	;SEGMENTATE TO MEMORY TABLE
	MOV AX, _MEMORY_TABLE_
	MOV ES, AX
	XOR BX, BX
.FLAG_IT:
	MOV CX, WORD [.TABLE_SEG] ;LOOK FOR SEGMENT
	SUB CX, 3000H ;SUBSTRACT RESERVED SEGMENTS
	MOV BX, CX ;BX NOW POINTS AT ENTRY
	
	;SET THE FLAG
	MOV BYTE AL, [.FLAG]
	MOV BYTE [ES:BX], BYTE AL
	
	STC ;SUCESS!
.END:
	POP ES
	POP CX
	POP BX
	POP AX
	RET

.ERROR:
	CLC
	JMP .END

	.TABLE_SEG		DW 0
	.FLAG			DB 0
	
;=======================================================================
;
;IO.STRING - MANAGE, SEARCH AND CUT STRINGS AT YOUR WILL
;
;=======================================================================

;IN = SI: STRING
;OUT = CX: LENGHT OF STRING (DOES NOT INCLUDE NULL)
STRING_LENGHT:
	PUSHA
	XOR CX, CX
.LOOP:
	CMP BYTE [SI], 0 ;IF AL IS ZERO
	JE .END
	
	INC CX ;ELSE KEEP ADDING
	INC SI
	JMP .LOOP
.END:
	MOV WORD [.LENGHT], CX
	POPA
	MOV CX, WORD [.LENGHT]
	RET
	.LENGHT		DW 0
	
;IN = SI: STRING TO COPY, DI: DESTINATION
;OUT = DI: STRING
STRING_COPY:
	PUSHA
.LOOP:
	LODSB
	
	CMP AL, 0
	JE .END
	
	STOSB
	JMP .LOOP
.END:
	MOV AL, 0
	STOSB
	POPA
	RET
	
;IN = SI: STRING
;OUT = DI: REVERSED STRING
STRING_REVERSE:
	PUSHA
	CALL STRING_LENGHT
	MOV WORD [.LENGHT], CX
	MOV DI, SI
	ADD DI, WORD [.LENGHT]
	SUB DI, 1 ;DO NOT COPY NULL CHARACTER
.LOOP:
	MOV AL, BYTE [DI]
	MOV AH, BYTE [SI]
	MOV BYTE [DI], AH
	MOV BYTE [SI], AL
	
	INC SI
	DEC DI
	
	CMP DI, SI
	JA .LOOP
.END:
	POPA
	RET
	
	.LENGHT DW 0
	
;IN = SI: STRING
;OUT = CARRY FLAG SET IF TRUE, ELSE FALSE
STRING_IS_EMPTY:
	CMP BYTE [SI], 0
	JE SHORT .YES
.NO:
	CLC
	RET
.YES:
	STC
	RET

;IN = SI: STRING, CX: PLACE WHERE CHARACTER SHOULD BE, AL: CHARACTER TO FIND
;OUT = FLAG CLEAR IF TRUE, ELSE SET IF FALSE
STRING_CHECK_CHARACTER_IN_LOCATION:
	PUSHA
	ADD SI, CX
	CMP BYTE [SI], AL
	JE .YES ;IF YES, ELSE DO NO
.NO: ;NO CHARACTER IN LOCATION
	POPA
	STC
	RET
.YES: ;YES
	POPA
	CLC
	RET
	
;IN = SI: STRING, DI: TOKENIZED STRING, AL: SEPARATOR CHARACTER
;OUT = DI: TOKENIZED STRING
STRING_TOKENIZE:
	PUSHA
	MOV DL, AL ;SAVE AL IN DL
.LOOP:
	LODSB ;GET CHARACTER, PLOT IT ON AL
	CMP AL, DL ;IF AL = DL, THEN WE HAVE A SEPARATOR!
	JE .DIVIDE ;TIME TO DIVIDE
	CMP AL, 0
	JE .END
	
	STOSB ;IF ITS A NORMAL CHARACTER JUST PUT IT
	JMP .LOOP
.DIVIDE:
	MOV AL, 0 ;MAKE SEPARATOR INTO NULL
	STOSB
	JMP .LOOP
.END:
	MOV AL, 0
	STOSB
	POPA
	RET
	
;IN = SI: STRING, AL: CHARACTER
;OUT = FLAG CLEAR IS TRUE, ELSE IF FALSE
STRING_HAS_CHARACTER:
	PUSH AX
	PUSH SI
.LOOP:
	CMP BYTE [SI], 0
	JE .NO
	CMP BYTE [SI], AL
	JE .YES
	INC SI
	JMP .LOOP
.NO:
	STC
	JMP .END
.YES:
	CLC
.END:
	POP SI
	POP AX
	RET

;IN = SI: STRING, DI: RESULTANT STRING, AL: CHARACTER TO REPLACE, AH: REPLACEMENT FOR CHARACTER AL
;OUT = DI: RESULTANT STRING
STRING_REPLACE_CHARACTER:
	PUSHA
	MOV DL, AL ;SAVE AL IN DL
	MOV DH, AH ;SAME WITH AH...
.LOOP:
	LODSB ;GET CHARACTER, PLOT IT ON AL
	CMP AL, DL ;IF AL = DL, THEN WE HAVE A CHARACTER TO REPLACE
	JE .REP ;TIME TO REPLACE
	CMP AL, 0
	JE .END
	STOSB
	JMP .LOOP
.REP:
	MOV AL, DH
	STOSB
	JMP .LOOP
.END:
	MOV AL, 0
	STOSB
	POPA
	RET
	
;IN = SI: STRING 1, DI: STRING 2
;OUT = CARRY FLAG SET IF EQUAL
STRING_COMPARE:
	PUSH AX
	PUSH_INDEXES
	XOR AX, AX ;ELIMINATE ANY AX LEFT
.LOOP:
	MOV AL, BYTE [SI] ;GET BYTES
	MOV AH, BYTE [DI]
	
	CMP AL, AH ;ARE THEY EQUAL?
	JNE NEAR .NOT_EQUAL
	
	TEST AX, AX ;DID WE GOT A ZERO?
	JZ NEAR .EQUAL

	ADD SI, 1 ;INCREMENT ONE BYTE...
	ADD DI, 1
	JMP .LOOP
.NOT_EQUAL:
	CLC
	JMP .END
.EQUAL:
	STC
.END:
	POP_INDEXES
	POP AX
	RET

;=======================================================================
;
;IO.TEXT - IO'S TEXT FOR ALL FUNCTIONS
;
;=======================================================================
	
DISK_ERROR_STRING:
	.INVALID_COMMAND						DB 'INVALID COMMAND',0							;01
	.ADDRESS_MARK_NOT_FOUND					DB 'ADDRESS MARK NOT FOUND',0					;02
	.WRITE_PROTECTED						DB 'DISK IS WRITE PROTECTED',0					;03
	.SECTOR_NOT_FOUND						DB 'SECTOR NOT FOUND',0							;04
	.RESET_FAILED							DB 'DISK RESET FAILED',0						;05
	.FLOPPY_DISK_REMOVED					DB 'FLOPPY DISK WAS REMOVED',0					;06
	.BAD_PARAMETER_TABLE					DB 'BAD DISK PARAMETER TABLE',0					;07
	.DMA_OVERRUN							DB 'DMA OVERRUN',0								;08
	.DMA_CROSSED_64K						DB 'DMA CROSSED 64KB BOUNDARY',0				;09
	.BAD_SECTOR_FLAG						DB 'BAD SECTOR FLAG SET',0						;0A
	.BAD_TRACK_FLAG							DB 'BAD TRACK FLAG SET',0						;0B
	.MEDIA_TYPE_NOT_FOUND					DB 'MEDIA TYPE NOT FOUND',0						;0C
	.INVALID_NUMBER_OF_SECTORS				DB 'INVALID NUMBER OF SECTORS',0				;0D
	.CONTROL_DATA_ADDRESS_MARK				DB 'CONTROL ADDRESS MARK DETECTED',0			;0E
	.DMA_ARBITRATION_LEVEL_OUT_OF_RANGE		DB 'DMA ARBITRATION LEVEL OUT OF RANGE',0		;0F
	.UNCORRECTABLE_CRC_ECC_DATA_ERROR		DB 'UNCORRECTABLE CRC OR ECC DATA ERROR',0		;10
	.ECC_CORRECTED_DATA_ERROR				DB 'ECC CORRECTED DATA ERROR',0					;11
	.CONTROLLER_FAILED						DB 'CONTROLLER FAILED',0						;20
	.SEEK_FAILED							DB 'SEEK FAILURE',0								;40
	.DISK_TIME_OUT							DB 'DISK TIMEOUT',0								;80
	.DRIVE_NOT_READY						DB 'DRIVE NOT READY',0							;AA
	.UNDEFINED_ERROR						DB 'UNDEFINED ERROR',0							;BB
	.WRITE_FAULT							DB 'WRITE FAULT',0								;CC
	.STATUS_REGISTER_ERROR					DB 'STATUS_REGISTER_ERROR',0					;E0
	.SENSE_OPERATION_FAILED					DB 'SENSE OPERATION FAILED',0					;FF
	.UNKNOWN								DB 'UNKNOWN DISK ERROR',0						;??
KERNEL_TEXT:
	;OS INFORMATION
	.OS_NAME 								DB 'LEAF DOS',0
	.OS_VERSION 							DB '0.1.5',0
	;ERRORS
	.ERROR_UNKNOWN_COMMAND					DB 'IS NOT A COMMAND OR FILE',0
	;MISC
	.NEWLINE								DB 13,10
DISK_INFO:
	.DRIVE_NUMBER							DB 0
	.SECTORS_PER_TRACK 						DW 18
	.SIDES 									DW 2

	KEYBOARD_BUFFER							TIMES 11 DB 0 	;KEYBOARD BUFFER
	PROGRAM_TO_LOAD							TIMES 11 DB 0 	;REQUESTED PROGRAM TRANSFORMED INTO
															;A SIMPLE FAT12 FRIENDLY STRING
